Question Name,Question Description,Question Declaration,Question Solution,Question Tests,Original Question
Uncommon characters,"Given two strings A and B consisting of lowercase english characters. Find the characters that are not common in the two strings. 
Note :- Return the string in sorted order.
Example 1:
Input:
A = geeksforgeeks
B = geeksquiz
Output: fioqruz
Explanation: 
The characters 'f', 'i', 'o', 'q', 'r', 'u','z' 
are either present in A or B, but not in both.
Example 2:
Input:
A = characters
B = alphabets
Output: bclpr
Explanation: The characters 'b','c','l','p','r' 
are either present in A or B, but not in both.
Your Task:  
You dont need to read input or print anything. Complete the function UncommonChars() which takes strings A and B as input parameters and returns a string that contains all the uncommon characters in sorted order. If no such character exists return ""-1"".
Expected Time Complexity: O(M+N) where M and N are the sizes of A and B respectively.
Expected Auxiliary Space: O(M+N)  
Constraints:
1<= M,N <= 104
String may contain duplicate characters.
 
","def uncommonChars(A, B):
    """"""
    type A: str
    type B: str
    type return: str
    """"""
    pass
","def uncommonChars_answer(A, B):
    """"""
    type A: str
    type B: str
    type return: str
    """"""
    res = ''

    # creating a list to keep track of presence of characters.
    present = [0] * 26

    # iterating over first string and marking presence of each character.
    for e in A:
        present[ord(e) - ord('a')] = 1

    # iterating over second string and updating presence list accordingly.
    for e in B:
        if present[ord(e) - ord('a')] == 1 or present[ord(e) - ord('a')] == -1:
            present[ord(e) - ord('a')] = -1
        else:
            present[ord(e) - ord('a')] = 2

    res = ''

    # iterating over the presence list to get the uncommon characters.
    for i, e in enumerate(present):
        if e == 1 or e == 2:
            res += chr(i + ord('a'))
    
    # returning the result.
    if res:
        return res
    else:
        return ""-1""

","test_cases = [
    (""geeksforgeeks"", ""geeksquiz""),  # Expected: ""fioqruz"", Test Passed
    (""characters"", ""alphabets""),  # Expected: ""bclpr"", Test Passed
    (""abc"", ""def""),  # Expected: ""abcdef"", Test Passed
    ("""", """"),  # Expected: ""-1"", Test Passed (Both strings are empty)
    (""abc"", """"),  # Expected: ""abc"", Test Passed (One string is empty)
    ("""", ""xyz""),  # Expected: ""xyz"", Test Passed (One string is empty)
    (""abcdef"", ""abcdef""),  # Expected: ""-1"", Test Passed (Both strings are identical)
    (""aaa"", ""bbb""),  # Expected: ""ab"", Test Passed
    (""abcd"", ""abef""),  # Expected: ""cdef"", Test Passed
    (""geek"", ""geeky"")  # Expected: ""y"", Test Passed
]

user_solution = uncommonChars
solution = uncommonChars_answer",Check for subsequence
Non Repeating Character,"Given a string s consisting of lowercase Latin Letters. Return the first non-repeating character in s. If there is no non-repeating character, return '$'.
Note : When you return '$' driver code will output -1.
Examples:
Input:
s = hello
Output: h
Explanation: In the given string, the first character which is non-repeating is h, as it appears first and there is no other 'h' in the string.
Input:
s = zxvczbtxyzvy
Output: c
Explanation: In the given string, 'c' is the character which is non-repeating.
Expected Time Complexity: O(n).
Expected Auxiliary Space: O(Number of distinct characters).
Note: n = |S|
Constraints:
1 <= n <= 105
 
","def nonRepeatingCharacter(s):
    """"""
    type s: str
    type return: str
    """"""
    pass
","def nonRepeatingCharacter_answer(s):
    """"""
    type s: str
    type return: str
    """"""
    # using hash table to store count of each character.
    occurences = [0 for i in range(256)]
    
    # iterating over the string.
    for char in s:
        occurences[ord(char)] += 1
    
    for i in range(len(s)):
        # if count of current character is 1, we return it.
        if occurences[ord(s[i])] == 1:
            return s[i]
    
    # if there is no non-repeating character then we return '$'.
    return '$'

","test_cases = [
    (""hello"",),  # Expected: ""h"", Test Passed
    (""zxvczbtxyzvy"",),  # Expected: ""c"", Test Passed
    (""abcdef"",),  # Expected: ""a"", Test Passed
    (""aabbcc"",),  # Expected: ""$"", Test Passed
    (""racecar"",),  # Expected: ""e"", Test Passed
    (""aabbc"",),  # Expected: ""c"", Test Passed
    ("""",),  # Expected: ""$"", Test Passed (Empty string)
    (""zzzyyyxxx"",),  # Expected: ""$"", Test Passed
    (""geeksforgeeks"",),  # Expected: ""f"", Test Passed
    (""abcdefgabcdefg"",)  # Expected: ""$"", Test Passed
]



user_solution = nonRepeatingCharacter
solution = nonRepeatingCharacter_answer",Check for subsequence
Multiply two strings,"Given two numbers as strings s1 and s2. Calculate their Product.

Note: The numbers can be negative and You are not allowed to use any built-in function or convert the strings to integers. There can be zeros in the begining of the numbers. You don't need to specify '+' sign in the begining of positive numbers.
Example 1:
Input:
s1 = ""0033""
s2 = ""2""
Output:
66
Example 2:
Input:
s1 = ""11""
s2 = ""23""
Output:
253
Your Task: You don't need to read input or print anything. Your task is to complete the function multiplyStrings() which takes two strings s1 and s2 as input and returns their product as a string.

Expected Time Complexity: O(n1* n2)
Expected Auxiliary Space: O(n1 + n2); where n1 and n2 are sizes of strings s1 and s2 respectively.
Constraints:
1 ≤ length of s1 and s2 ≤ 103
","def multiplyStrings(s1, s2):
    """"""
    type s1: str
    type s2: str
    type return: str
    """"""
    pass
","def multiplyStrings_answer(s1, s2):
    """"""
    type s1: str
    type s2: str
    type return: str
    """"""
    # Checking if either of the strings is zero
    if s1 == '0' or s2 == '0':
        return '0'
    
    # Setting s1 variable to keep track of the sign of the product
    negative = False
    # Checking if the first string is negative
    if s1[0] == '-':
        negative = not negative
        s1 = s1[1:]
    
    # Checking if the second string is negative
    if s2[0] == '-':
        negative = not negative
        s2 = s2[1:]
    
    # Initializing s1 list to store the product
    product = [0 for _ in range(len(s1) + len(s2))]
    
    # Multiplying each digit of the second string with each digit of the first string
    for i in range(len(s2) - 1, -1, -1):
        digit1 = int(s2[i])
        carry = 0
        
        # Iterating over each digit of the first string
        for j in range(len(s1) - 1, -1, -1):
            digit2 = int(s1[j])
            
            # Adding the product of the digits with the carry
            product[i + j + 1] += digit1 * digit2 + carry
            carry = product[i + j + 1] // 10
            product[i + j + 1] = product[i + j + 1] % 10
        
        # Handling any remaining carry
        nextIndex = i
        while carry:
            product[nextIndex] += carry
            carry = product[nextIndex] // 10
            product[nextIndex] = product[nextIndex] % 10
            nextIndex -= 1
    
    # Converting the product list to s1 string
    res = ''.join(str(x) for x in product)
    
    # Removing leading zeroes from the product
    zeroes = 0
    while zeroes < len(res) - 1 and res[zeroes] == '0':
        zeroes += 1
    res = res[zeroes:]
    
    # Adding the negative sign if necessary
    if negative and res != ""0"":
        res = '-' + res
    
    # Returning the final product
    return res

","test_cases = [
    (""0033"", ""2""),  # Expected: ""66"", Test Passed
    (""11"", ""23""),  # Expected: ""253"", Test Passed
    (""-11"", ""23""),  # Expected: ""-253"", Test Passed
    (""0"", ""12345""),  # Expected: ""0"", Test Passed
    (""123"", ""0""),  # Expected: ""0"", Test Passed
    (""-123"", ""-456""),  # Expected: ""56088"", Test Passed
    (""00012"", ""00034""),  # Expected: ""408"", Test Passed
    (""999"", ""999""),  # Expected: ""998001"", Test Passed
    (""1"", ""1""),  # Expected: ""1"", Test Passed
    (""123456789"", ""987654321"")  # Expected: ""121932631112635269"", Test Passed
]


user_solution = multiplyStrings
solution = multiplyStrings_answer",Check for subsequence
Check for subsequence - Fix The Bugs,"Given two strings A and B, find if A is a subsequence of B.
Example 1:
Input:
A = AXY 
B = YADXCP
Output: 0 
Explanation: A is not a subsequence of B
as 'Y' appears before 'A'.
 
Example 2:
Input:
A = gksrek
B = geeksforgeeks
Output: 1
Explanation: A is a subsequence of B.
 
Your Task:  
You dont need to read input or print anything. Complete the function isSubSequence() which takes A and B as input parameters and returns a boolean value denoting if A is a subsequence of B or not. 
 
Expected Time Complexity: O(N) where N is length of string B.
Expected Auxiliary Space: O(1)
Constraints:
1<= |A|,|B| <=104
","def isSubSequence(A, B):
    """"""
    type A: str
    type B: str
    type return: bool
    """"""
    i = j = 0
    
    # iterating over A and B to check if characters match.
    while j < len(B) and i < len(A)+1:
        if A[j] == B[i]:
            j += 1
            i += 1
    
    # returning True if A is a subsequence of B, else False.
    return j == len(A)","def isSubSequence_answer(A, B):
    """"""
    type A: str
    type B: str
    type return: bool
    """"""
    i = j = 0
    
    # iterating over A and B to check if characters match.
    while i < len(B) and j < len(A):
        if A[j] == B[i]:
            j += 1
        i += 1
    
    # returning True if A is a subsequence of B, else False.
    return j == len(A)

","test_cases = [
    (""AXY"", ""YADXCP""),   # Expected: False, Test Passed
    (""gksrek"", ""geeksforgeeks""),  # Expected: True, Test Passed
    (""abc"", ""ahbgdc""),  # Expected: True, Test Passed
    (""axc"", ""ahbgdc""),  # Expected: False, Test Passed
    ("""", ""ahbgdc""),     # Expected: True, Test Passed (Empty A is always a subsequence)
    (""ahbgdc"", ""ahbgdc""),  # Expected: True, Test Passed
    (""ahbgdc"", """"),     # Expected: False, Test Passed (A cannot be subsequence of empty B)
    (""abc"", ""abcabc""),  # Expected: True, Test Passed
    (""longerstring"", ""short""),  # Expected: False, Test Passed
    (""xyz"", ""xaybz"")   # Expected: True, Test Passed
]

user_solution = isSubSequence
solution = isSubSequence_answer",Check for subsequence
